# Chapter 7: Streaming - Real-time Recipe Generation with Genkit Go

This example demonstrates real-time streaming capabilities in Genkit Go by implementing a streaming flow that generates detailed cooking recipes chunk by chunk. The application showcases how to create responsive AI applications that provide immediate feedback to users as content is being generated.

## Features

- Real-time streaming flow using OpenAI GPT-5
- Intelligent content chunking for optimal user experience
- Professional chef system prompt for high-quality recipe generation
- Server-Sent Events (SSE) streaming protocol
- Dart client implementation for cross-platform integration
- Smart buffering system for coherent content delivery
- Sentence-boundary detection for natural streaming breaks

## Streaming Technology

### Server-Side Streaming
The application uses Genkit's `DefineStreamingFlow` to create flows that can stream content progressively. The streaming implementation includes:

- **Content Buffering**: Accumulates chunks until complete sentences are formed
- **Smart Breaking Points**: Detects natural sentence boundaries (periods, exclamation marks, question marks)
- **Progressive Delivery**: Streams content as it becomes available without waiting for complete generation
- **Error Handling**: Graceful handling of streaming interruptions

### Client Integration
Includes a Dart client implementation demonstrating how to consume streaming endpoints from mobile and web applications.

## API Endpoints

### 1. Recipe Steps Flow (Streaming)
**Endpoint:** `POST /recipeStepsFlow`

Generates detailed cooking recipes with real-time streaming delivery. Content is streamed as Server-Sent Events (SSE) with `Content-Type: text/event-stream`.

## Running the Example

1. Set up your OpenAI API key:
   ```bash
   export OPENAI_API_KEY="your-openai-api-key-here"
   ```

2. Run the application:
   ```bash
   go run .
   ```

4. The server will start and you can make POST requests to:
   - `POST /recipeStepsFlow` - Stream recipe generation in real-time

## Example Usage

### Streaming Recipe Generation
Send requests for various dishes:
- `"Beef Stroganoff"`
- `"Chocolate Chip Cookies"`
- `"Thai Green Curry"`
- `"Homemade Pizza"`
- `"Caesar Salad"`

The response will stream progressively, delivering recipe content as it's generated by the AI model.

## cURL Examples

### Stream Recipe Generation
```bash
curl -X POST http://127.0.0.1:9090/recipeStepsFlow \
  -H "Content-Type: application/json" \
  -d '{"data":"Beef Stroganoff"}' \
  --no-buffer
```

**Note**: Use `--no-buffer` flag to see streaming output in real-time.

**Example Streaming Response:**
```
data: {"type":"content","content":"# Beef Stroganoff\n\n"}

data: {"type":"content","content":"## Ingredients:\n- 1 lb beef sirloin, sliced thin\n"}

data: {"type":"content","content":"- 8 oz mushrooms, sliced\n- 1 onion, diced\n"}

data: {"type":"content","content":"- 2 cups beef broth\n- 1 cup sour cream\n"}

data: {"type":"content","content":"\n## Instructions:\n\n"}

data: {"type":"content","content":"1. Heat oil in a large skillet over medium-high heat.\n"}

data: {"type":"done"}
```

## Running with Genkit CLI

With your application running via `genkit start -- go run .`, open another terminal and use the Genkit CLI with streaming support:

```bash
# Note: Use -s flag for streaming output
genkit flow:run recipeStepsFlow -s '"Beef Stroganoff"'
```

## Project Structure

- `main.go` - Entry point with streaming flow setup and OpenAI configuration
- `internal/flows/` - Flow implementations
  - `recipe.go` - Streaming recipe generation flow with intelligent chunking
- `client/` - Client implementations
  - `bin/streaming_client.dart` - Dart client for consuming streaming endpoints
  - `pubspec.yaml` - Dart dependencies configuration

## Streaming Implementation Details

### Content Chunking Strategy

The streaming flow implements sophisticated content chunking:

```go
// Buffer accumulates chunks until meaningful units are formed
var buffer string

// Stream when complete sentences or paragraphs are ready
for {
    breakPoint := -1
    for i, r := range buffer {
        if r == '.' || r == '\n' || r == '!' || r == '?' {
            if i+1 < len(buffer) && (buffer[i+1] == ' ' || buffer[i+1] == '\n') {
                breakPoint = i + 1
                break
            }
        }
    }
    
    if breakPoint > 0 {
        toSend := buffer[:breakPoint]
        buffer = buffer[breakPoint:]
        stream(ctx, toSend)
    } else {
        break // Wait for more content
    }
}
```

## Dart Client Usage

The included Dart client demonstrates streaming consumption:

```bash
cd client
dart pub get
dart run bin/streaming_client.dart
```

The client handles:
- HTTP streaming connection management
- Server-Sent Events parsing
- Real-time content display
- Connection error recovery

## Use Cases

This streaming pattern is ideal for:

- **Recipe Generation**: Step-by-step cooking instructions
- **Creative Writing**: Stories, articles, and long-form content
- **Code Generation**: Progressive code completion
- **Educational Content**: Tutorials and explanations
- **Real-time Analysis**: Progressive data processing results

This example provides a solid foundation for building responsive, real-time AI applications with Genkit Go.
